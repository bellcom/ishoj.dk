<?php

/**
 * @file
 * Integrates the PURL module directly with Context, Views, and other modules.
 */

include DRUPAL_ROOT . '/' . drupal_get_path('module', 'sites') . '/site.inc';
include DRUPAL_ROOT . '/' . drupal_get_path('module', 'sites') . '/sites.context.inc';
include DRUPAL_ROOT . '/' . drupal_get_path('module', 'sites') . '/sites.core.inc';
include DRUPAL_ROOT . '/' . drupal_get_path('module', 'sites') . '/sites.purl.inc';
include DRUPAL_ROOT . '/' . drupal_get_path('module', 'sites') . '/sites.views.inc';

/**
 * Implements hook_init().
 */
function sites_init() {
  if (function_exists('strongarm_set_conf')) {
    // Reset strongarm configuration.
    strongarm_set_conf(TRUE);
  }

  // Set current site name
  global $conf;
  $site = sites_get_current_site();
  if (!empty($site)) {
    $conf['site_name'] = $site->name;
  }
}

/**
 * Implements hook_menu().
 */
function sites_menu() {
  $items['admin/structure/sites'] = array(
    'title' => 'Sites',
    'description' => 'Manage sites.',
    'page callback' => 'sites_page_admin_overview',
    'access arguments' => array('administer sites'),
    'file' => 'sites.admin.inc',
  );

  $items['admin/structure/sites/add'] = array(
    'title' => 'Add site',
    'description' => '',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sites_site_form'),
    'access arguments' => array('administer sites'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'sites.admin.inc',
  );

  $items['admin/structure/sites/edit/%'] = array(
    'title' => 'Edit site',
    'description' => '',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sites_site_form', 4),
    'access arguments' => array('administer sites'),
    'file' => 'sites.admin.inc',
  );

  $items['admin/structure/sites/delete/%'] = array(
    'title' => 'Delete site',
    'description' => '',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sites_site_delete_form', 4),
    'access arguments' => array('administer sites'),
    'file' => 'sites.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function sites_theme($existing, $type, $theme, $path) {
  return array(
    'sites_list_sites' => array(
      'variables' => array(),
      'file' => 'sites.admin.inc',
    ),
  );
}

/**
 * Implements hook_custom_theme().
 */
function sites_custom_theme() {
  if (user_access('view the administration theme') && path_is_admin(current_path())) {
    return variable_get('admin_theme');
  }
  $theme_name = SiteController::getCurrentTheme();
  if (is_string($theme_name)) {
    return $theme_name;
  }
}

/**
 * Implements hook_admin_paths().
 *
 * Adds the sites admin paths as admin paths, so the admin theme is used.
 */
function sites_admin_paths_alter(&$paths) {
  if (SiteController::isSitePurlModifier()) {
    $paths_copy = $paths;
    $purl_prefix = arg(0);
    foreach ($paths_copy as $key => $value) {
      $paths[$purl_prefix . '/' . $purl_prefix . '/' . $key] = TRUE;
    }
  }
}

/**
 * Implements hook_url_inbound_alter().
 *
 * Because the site purl is saved with the alias, we need to make sure purl
 * and context are working correctly.
 */
function sites_url_inbound_alter(&$result, $path, $path_language) {
  if (purl_inited() == TRUE) {
    // Purl is recognised and will work as default
    $result = purl_inited() ? purl_get_normal_path($path) : $path;
  }
  else {
    $paths = explode('/', $path);
    $purl_prefix = reset($paths);
    // A sites purl modifier is active, but purl has not been initiated. Add the
    // purl prefix to the path.
    if (count($paths) > 1 && $purl_prefix && SiteController::isSitePurlModifier()) {
      $result = $purl_prefix . '/' . $path;
    }
  }
}


/**
 * Implements hook_url_outbound_alter().
 *
 * - Adds site prefix to content admin.
 * - Removes prefix from node aliases if prefix was added on node update.
 */
function sites_preview_url_outbound_alter(&$path, &$options, $original_path) {
  // we'll rewrite the outbound url for node/edit and node/delete
  // I only do this so that all links on admin/content are being redirected properly
  // only when we are not in a site.
  if (current_path() == 'admin/content') {
    purl_disable(TRUE);
    if (isset($options['title'])) {
      if ($options['title'] == 'edit' || $options['title'] == 'delete') {
        if ($options['href']) {
          $paths = explode('/', $options['href']);
          if ($paths[0] == 'node') {
            $nid = $paths[1];
            $sites = SiteController::getSitesByNode($nid);
            foreach ($sites as $site) {
              $path = $site->value . '/' . $path;
            }
          }
        }
      }
    }
  }
  // Remove the purl prefix from node aliases that already have a purl prefix.
  if (stripos($path, 'node/') === 0) {
    $alias = drupal_get_path_alias($path);
    $site = SiteController::getCurrentSite();
    $parts = explode('/', $alias);
    // Only remove the prefix if the alias is already prefixed.
    if ($alias && isset($site->purl_prefix) && $parts[0] === $site->purl_prefix && count($parts) > 1) {
      array_shift($parts);
      // Set the path to the alias.
      $path = implode('/', $parts);
      // When this alias option is set to TRUE drupal will not attempt to
      // override the alias again.
      $options['alias'] = TRUE;
    }
  }
}

/**
 * Implements template_preprocess_page.
 */
function sites_process_page(&$vars) {
  // Some themes acquire their primary_links and secondary_links variables via
  // these variables.  For themes that do not, we have provided a Strongarm
  // implementation in sites_strongarm()
  if ($pl = sites_get_current_menu_source('main_menu')) {
    $vars['main_menu'] = module_exists('i18n_menu') ? i18n_menu_navigation_links($pl) : menu_navigation_links($pl);
  }
  if ($sl = sites_get_current_menu_source('secondary_menu')) {
    $vars['secondary_menu'] = module_exists('i18n_menu') ? i18n_menu_navigation_links($sl) : menu_navigation_links($sl);
  }
}

/**
 * Implements template_preprocess_page.
 */
function sites_preprocess_page(&$vars) {
  $site = sites_get_current_site();
  if (! empty($site)) {
    if ($site->purl_prefix) {
      $vars['front_page'] = url($site->purl_prefix);
    }
  }
}

/**
 * Implements hook_permission().
 */
function sites_permission() {
  return array(
    'administer sites' => array(
      'title' => t('Administer sites'),
    ),
  );
}

/**
 * Implements hook_user_logout().
 */
function sites_user_logout($account) {
  // Disable purl for user logout, otherwise it redirects to the same page.
  purl_disable(TRUE);
}

/**
 * Implements hook_form_alter().
 *
 * Adds sites checkboxes to the node add/edit form.
 */
function sites_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form['type']) && isset($form['#node'])) {
    if ($form['type']['#value'] . '_node_form' == $form_id) {
      $node = $form['#node'];
      $sites_form_elements = SiteHelper::buildSiteFormElement($node);
      // Add the sites checkboxes.
      $form['sites-options'] = $sites_form_elements['sites-options'];
      // Alter the node form: restrict the available menu options if we're in a
      // site.
      SiteHelper::alterNodeForm($form);
      $form['actions']['submit']['#submit'][] = 'sites_node_form_submit';
    }
  }
}

/**
 * Handles submit for node form.
 *
 * Redirect to the subsite when saving a node, to avoid access denied.
 */
function sites_node_form_submit($form, &$form_state) {
  foreach ((array) $form_state['values']['sites'] as $site_id => $active) {
    // Load the first active site we find.
    if ($active && $site = SiteController::getSite($site_id)) {
      if (! empty($site->purl_prefix)) {
        // Change the redirect to include the purl prefix so that we don't get
        // an access denied.
        $form_state['redirect'] = $site->purl_prefix . '/' . $form_state['redirect'];
        return;
      }
    }
  }
}

/**
 * Implements hook_node_load().
 */
function sites_node_load($nodes, $types) {
  foreach ($nodes as $node) {
    $node->sites = sites_get_node_sites($node->nid);
  }
}

/**
 * Implements hook_node_insert().
 */
function sites_node_insert($node) {
  if (isset($node->sites)) {
    _sites_attach_node_to_sites($node->nid, (array) array_filter($node->sites));
  }
}

/**
 * Implements hook_node_update().
 */
function sites_node_update($node) {
  if (isset($node->sites)) {
    _sites_attach_node_to_sites($node->nid, (array) array_filter($node->sites));
  }
}

/**
 * Implements hook_block_info().
 */
function sites_block_info() {
  $block = array();
  $block['current_site']['info'] = t('Current site information');
  return $block;
}

/**
 * Implements hook_block_view().
 */
function sites_block_view($delta) {
  switch ($delta) {

    case 'current_site':
      $block = array(
        'subject' => t('Current Site'),
        'content' => sites_block_sites(),
      );
      break;

    default:
      break;
  }

  return $block;
}

/**
 * Block with current site information.
 */
function sites_block_sites() {
  $site = sites_get_current_site();

  $output = '';
  if (!empty($site)) {
    $output .= "
      <div class='row'>
        <span class='label'>SID:</span>
        <span class='field sid'>{$site->sid}</span>
      </div>
      <div class='row'>
        <span class='label'>Administrative title:</span>
        <span class='field title'>{$site->title}</span>
      </div>
      <div class='row'>
        <span class='label'>Name:</span>
        <span class='field name'>{$site->name}</span>
      </div>
      <div class='row'>
        <span class='label'>PURL prefix:</span>
        <span class='field purl_prefix'>{$site->purl_prefix}</span>
      </div>
      <div class='row'>
        <span class='label'>Front page:</span>
        <span class='field front_page'>{$site->front_page}</span>
      </div>
      <div class='row'>
        <span class='label'>Primary links:</span>
        <span class='field menu_main_menu'>{$site->menu_main_menu}</span>
      </div>
      <div class='row'>
        <span class='label'>Secondary links:</span>
        <span class='field menu_secondary_menu'>{$site->menu_secondary_menu}</span>
      </div>

    ";
  }
  return $output;
}

/**
 * Check the implementation of hook_sites_access with the heaviest weight
 * as to whether the node should be accessible.
 *
 * @param $node
 *   Node object.
 *
 * @return
 *   Boolean.
 */
function sites_access($node) {
  // Access is based on the heaviest weighted module's response
  $modules = module_implements('sites_access');
  $last = $modules[count($modules) - 1];
  $permitted = module_invoke($last, 'sites_access', $node);

  return $permitted;
}

/**
 * Implements hook_sites_access().
 */
function sites_sites_access($node) {
  if (isset($node->sites) && count($node->sites)) {
    // make sure purl is initialized.
    // when working with domain purl processor
    // hook_access is called before purl_init()
    purl_init();
    return in_array(sites_get_current_sid(), array_keys($node->sites));
  }
  else {
    // allow nodes without a defined site to be accessed freely
    return TRUE;
  }
}

/**
 * Implements hook_menu_alter().
 */
function sites_menu_alter(&$items) {
  $items['node/%node']['access callback'] = 'sites_menu_access_override_node_view';
}

/**
 * Wrapper for node_access that allows site_access to preempt default node access rules.
 */
function sites_menu_access_override_node_view($op, $node) {
  if (!sites_access($node)) {
    return FALSE;
  }
  else {
    return node_access($op, $node);
  }
}

/**
 * Implements hook_strongarm().
 */
function sites_strongarm() {
  $site = sites_get_current_site();

  if ($site) {
    $export = array();

    // primary links
    $main = sites_get_current_menu_source('main_menu');
    if ($main) {
      $strongarm = new stdClass;
      $strongarm->disabled = FALSE;
      $strongarm->api_version = 1;
      $strongarm->name = 'menu_main_menu_source';
      $strongarm->value = $primary;

      $export['menu_main_menu_source'] = $strongarm;
    }

    // secondary links
    $secondary = sites_get_current_menu_source('secondary_menu');
    if ($secondary) {
      $strongarm = new stdClass;
      $strongarm->disabled = FALSE;
      $strongarm->api_version = 1;
      $strongarm->name = 'menu_secondary_menu_source';
      $strongarm->value = $secondary;

      $export['menu_secondary_menu_source'] = $strongarm;
    }

    return $export;
  }
}

/**
 * Notify CTools that we'll be using the plugin API with Context and Strongarm modules.
 */
function sites_ctools_plugin_api($module, $api) {
  if ($module == 'context' && $api == 'plugins') {
    return array('version' => 3);
  }
  elseif ($module == "strongarm" && $api == "strongarm") {
    return array("version" => 1);
  }
}
